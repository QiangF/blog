---
layout: post
author: Train
description: "作者在学位论文写作过程中使用的软件介绍"
keywords: "LaTex, Prezi, EndNote"
---

前后历经一年的时间，学位论文终于完稿。往简单方面说，这是一个组织和整合已发表小论文内容的过程——撰写内容本身不再是主要问题，取而代之的是内容的连贯和文章的排版。然而，这依旧是一项浩大的工程，本文即记录此过程中使用的工具集合。

## 文献综述——Endnote+Prezi

`EndNote`是一款大众普及的文献管理工具，其备注、分组、格式化导出等功能已经在平时的文献阅读、期刊论文写作方面，为我们带来了极大的便利。不过，当我们处理学位论文综述部分上百篇文献及其相互关联时，`Endnote`中一条条文献记录的线性排列方式难以方便地给予我们一个从全局到细节的完全掌控。

这时候，希望将`EndNote`中依次排列的分组/文献平摊到一张无限大的白纸上，宏观上可以把握各个分类；当需要关注某一主题时，细节上又可以一览无余。这一切，可以借助`Prezi`实现！

> `Prezi`是一种主要通过缩放动作和快捷动作使想法更加生动有趣的演示文稿软件，它打破了传统Powerpoint的单线条时序，采用系统性与结构性一体化的方式来进行演示。
> <div style="text-align: right; font-style: italic;">——百度百科</div>

它的**缩放**功能正是我们所需的，宏观上便于把握各个主题，放大后即可关注具体内容，也就是拓展了我们的视野。以下两幅图片为宏观和细节的两个状态，此过程可以通过鼠标的滚轮连续地、平滑地过渡。

<div align='center'><img src="{{ "/images/2017-01-17-01.png" | prepend: site.baseurl }}"></div>

<div align='center'><img src="{{ "/images/2017-01-17-02.png" | prepend: site.baseurl }}"></div>

`Prezi`并不是文献管理工具，然而一旦结合`Endnote`使用，则是如虎添翼。

## 准备工作

为了顺利使用PyPost模块，需要将模块文件`py_post.pyd`（`\mentat2012\shlib\`）复制到Python的库文件目录（`\mentat2012\python\win64\Lib`），并且确保Python环境变量`PYTHONPATH`已经指向Python库文件目录。

这与使用其他Python模块是一样的，目的是让Python知道模块文件所在目录，然后才能用 `from py_post import *` 语句导入。

## 实例

从后处理文件中读取位移数据的基本思路为：

* 打开后处理文件
* 跳转到指定增量步
* 获取节点总数及每个节点的坐标和位移

``` python
# encoding: utf8
from py_post import *  # 导入PyPost模块
 
# 读取后处理文件
fname = "test_job1.t16" # 当前目录下的Marc后处理文件，否则给出具体路径
p = post_open(fname)    # 打开后处理文件
p.moveto(26)            # 跳转到第26增量步
 
# 节点数
num = p.nodes()
 
data = []
k = 0
# 获取每个节点的位移值
while k < num:
    pk = p.node(k)  # 第k个节点对象，x，y，z属性分别为三个坐标值
    if pk.x>=-8 and pk.x<=27:  # 选择x坐标在[-8, 27]范围内的节点
        dx, dy, _ = p.node_displacement(k)  # 获取位移
        data.append([pk.x, pk.y, dx, dy])
    k += 1
```

上面的代码可以实现节点坐标、位移的获取，接下来即可进行云图的绘制。

绘制云图的`contourf()`函数接受的是网格化数据，而当前`data`列表中的是离散数据，所以需要先生成网格化的坐标数据，然后根据`data`中的数据插值得到指定节点上的位移数据，最后以新的数据绘制云图。

借助Python科学计算库`Numpy`和绘图库`matplotlib`，示例代码如下：

``` python
# 接前面代码
 
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.mlab import griddata
 
data = np.array(data)
 
# 读取后处理文件得到的离散数据
xi = data[:,0] + 87.64
yi = data[:,1]
dzi = data[:,2]
dri = data[:,3]
 
# 生成网格化的坐标
dx = np.linspace(np.min(xi), np.max(xi), 500)
dy = np.linspace(np.min(yi), np.max(yi), 250)
x, y = np.meshgrid(dx, dy)
 
# 使用griddata插值得到节点上的位移值
dz = griddata(xi, yi, dzi, x, y)
dr = griddata(xi, yi, dri, x, y)
 
# 根据模型几何结构显示数据
k = 0.075
t = (y>k*x) * (y>6.59)
dz[t] = np.nan
dr[t] = np.nan
 
# 以轴向位移为例作云图
plt.figure()
c = plt.contourf(x, y, dz)
plt.colorbar(c)
plt.gca().set_aspect('equal')
plt.gca().set_axis_off()
plt.show()
```

最终效果如下：

<div align='center'><img src="{{ "/images/2016-01-20-01.png" | prepend: site.baseurl }}"></div>