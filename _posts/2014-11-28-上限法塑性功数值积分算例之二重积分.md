---
layout: post
author: Train
description: "实例对比二维区域上高斯积分、复化梯形公式、复化Simpson公式的积分精度"
keywords: "Matlab, 数值积分"
mathjax: true
---

上限法是一种解析方法，但有时候模型比较复杂，在塑性功积分环节还得求助于数值积分。在这里可能有两种思路：直接借助高斯积分和单元离散后简单数值积分。为了表现两者的差异，本文纯粹从数学算例角度予以对比——实现如下二重积分 [W = intlimits_{ - 1}^1 {intlimits_{ - 1}^1 {fleft( {x,y} right)} } dxdy = intlimits_{ - 1}^1 {intlimits_{ - 1}^1 {cos frac{pi }{2}left( {x + y} right)} } dxdy] <!--more-->
<h3>1 理论解</h3>
[begin{array}{c} W = - frac{2}{pi }intlimits_{ - 1}^1 {left. {sin frac{pi }{2}left( {x + y} right)} right|_{ - 1}^1} dy = - frac{2}{pi }intlimits_{ - 1}^1 {left[ {sin frac{pi }{2}left( {y + 1} right) - sin frac{pi }{2}left( {y - 1} right)} right]} dy\ = - frac{4}{{{pi ^2}}}left. {left[ {cos frac{pi }{2}left( {y + 1} right) - cos frac{pi }{2}left( {y - 1} right)} right]} right|_{ - 1}^1\ = - frac{{16}}{{{pi ^2}}} approx {rm{1}}{rm{.6211}} end{array}]
<h3>2 高斯积分</h3>
由于目标函数恰好在Gauss-Legendre的标准积分区间[-1,1]，可以直接取积分点代入二重高斯积分公式。于是W的n阶Gauss-Legendre积分近似值就可通过下式求得 [{W_n} = sumlimits_{i = 0}^n {sumlimits_{j = 0}^n {{A_i}{A_j}fleft( {{x_i},{y_j}} right)} } ] 其中(x_i,x_j)分别为(x,y)方向的积分点，(A_i)为对应的积分系数。 积分点及求积系数的求解可以参考相关文献。为方便起见，这里直接给出前2阶Gauss-Legendre求积公式的节点及系数： [begin{array}{l} n = 0:{bf{x}} = 0,{bf{A}} = 2\ n = 1:{bf{x}} = left[ { - frac{1}{{sqrt 3 }},frac{1}{{sqrt 3 }}} right],{bf{A}} = left[ {1,1} right]\ n = 2:{bf{x}} = left[ { - frac{{sqrt {15} }}{5},0,frac{{sqrt {15} }}{5}} right],{bf{A}} = left[ {frac{5}{9},frac{8}{9},frac{5}{9}} right] end{array}] 以上公式可以很容易编写Matlab代码，以2阶高斯积分为例
<pre class="lang:matlab decode:true" title="gauss">function w = fun_gauss(f)
    x = [-sqrt(15)/5,0,sqrt(15)/5];y = x;
    [X,Y] = meshgrid(x,y);
    a = [5/9,8/9,5/9];b = a;
    [A,B] = meshgrid(a,b);
    w = sum(sum(A.*B.*f(X,Y)));</pre>
于是得到 [{W_0} = 4,{W_1} = {rm{1}}{rm{.5188}},{W_2} = 1.6234]
<h3>3 单元离散后积分</h3>
为简单起见，将积分区域离散为(N=n^2)个面积相等的小区域，则每个单元的面积(ΔS=4/N)。当单元m足够小时，以单元4个节点对应函数值的平均值来近似该单元处的被积函数值，于是W可以表示为 $${W_n} = sum_{m = 1}^{N} {intlimits_{{y_{m - 1}}}^{{y_m}} {intlimits_{{x_{m - 1}}}^{{x_m}} {fleft( {x,y} right)dxdy} } } = sumlimits_{m = 1}^{N} {left[ {{1 over 4}sumlimits_{i = 1}^2 {sumlimits_{j = 1}^2 {fleft( {{x_i},{y_j}} right)Delta S} } } right]} = Delta Ssumlimits_{m = 1}^{N} {sumlimits_{i = 1}^2 {sumlimits_{j = 1}^2 {{{fleft( {{x_i},{y_j}} right)} over 4}} } } $$ 其中(x_1,x_2)为单元m的节点的两个横坐标。 

<div align='center'><img src="{{ "/images/2014-11-28_01.png" | prepend: site.baseurl }}"></div>

 上式可以理解为将区域离散后，每个单元的每个节点都为最终的积分值贡献1/4的作用。单从节点来看，内层节点贡献为1，边界节点（除4个角节点外）贡献1/2，4个角节点贡献1/4。这很容易通过Matlab编程实现，代码如下：
<pre class="lang:matlab decode:true" title="tixing">function w = fun_trapezoid(n,f)
    [X,Y] = meshgrid(linspace(-1,1,n));
    a = f(X(2:n-1,2:n-1),Y(2:n-1,2:n-1));
    b = f(X(1,:),Y(1,:))+f(X(n,:),Y(n,:));
    c = f(X(:,1),Y(:,1))+f(X(:,n),Y(:,n));
    d = f(X(1,1),Y(1,1))+f(X(1,n),Y(1,n))+f(X(n,1),Y(n,1))+f(X(n,n),Y(n,n));
    t = sum(sum(a)) + sum(b)/2 + sum(c)/2 - d/4;
    w = 4*t/n^2;</pre>
于是得到 $${W_{10}} = {rm{1}}{rm{.2865}},{W_{100}} = {rm{1}}{rm{.5886}},{W_{5000}} = {rm{1}}{rm{.6205}}$$ 这样的积分结果差强人意，单元数达到5000×5000时才达到小数点后2位的精度。为了改善精度，在子域上使用Simpson求积公式，得到 $${W_n} = sumlimits_{m = 1}^ {N}{intlimits_{{y_{m - 1}}}^{{y_m}} {intlimits_{{x_{m - 1}}}^{{x_m}} {fleft( {x,y} right)dxdy} } } = sumlimits_{m = 1}^ {N}{left[ {{1 over {36}}sumlimits_{i = 1}^3 {sumlimits_{j = 1}^3 {{A_i}{A_j}fleft( {{x_i},{y_j}} right)Delta S} } } right]} = {{Delta S} over {36}}sumlimits_{m = 1}^ {N}{sumlimits_{i = 1}^3 {sumlimits_{j = 1}^3 {{A_i}{A_j}fleft( {{x_i},{y_j}} right)} } } $$ 其中(x_1,x_2,x_3)分别为单元m的边的三个等分点的横坐标。A为积分系数，(A=[1,4,1])。 

<div align='center'><img src="{{ "/images/2014-11-28_02.png" | prepend: site.baseurl }}"></div>

 Matlab编码为
<pre class="lang:matlab decode:true" title="simpson">function w = fun_simpson(n,f)
    t = 2/n;
    [A,B] = meshgrid([1,4,1],[1,4,1]);
    w = 0.0;
    for i = 0:n^2-1
    x = mod(i,n);
    y = floor(i/n);    
    x = -1 + x*t;
    y = -1 + y*t;
    [X,Y] = meshgrid(linspace(x,x+t,3),linspace(y,y+t,3));
    w = w + sum(sum(A.*B.*f(X,Y)/(3*n)^2));
    end</pre>
最终计算结果为 $${W_2} = {rm{1}}{rm{.6285}},{W_5} = {rm{1}}{rm{.6213}},{W_{10}} = {rm{1}}{rm{.6211}}$$
<h3>4 总结</h3>
高斯积分以积分点的计算为代价可以在较少积分点的情况下依旧获得一定的精度，而离散积分的方法以离散单元数为代价来提高精度；但是精度会因为子域上选取的积分方式的不同而表现出较大的差异：当只有单元节点参与计算时，精度相对较低；而当单元边界中点也加入计算，精度得以很大提高。
<blockquote class="sumary">区域离散后积分的方法本质上是复化求积法——通过划分子区间并在子区间上使用低阶求积公式来提高精度并兼顾计算复杂程度。第一种求积方法采用的是梯形公式，第二种采用的是相比更高精度的Simpson公式（即2阶Newton-Cotes公式）。这种方法的优势在于当积分区域极不规则时，可以通过离散的方法在子区间上进行积分并最终累加。例如实际三维成形问题，由于积分区域无法直接写成显式的积分上下限形式，因此也无法直接在全域上使用高斯求积公式。</blockquote>
综合来看，在上限法分析模型中，一般二维即平面应变或轴对称模型的积分区域是规则的，因此高斯积分法可能有应用优势；而三维问题往往变形区域复杂度很大，所以为积出塑性功，离散求积的方法更具优势（算例参见<a href="http://scientia.sinaapp.com/%E4%B8%8A%E9%99%90%E6%B3%95%E4%B8%AD%E5%A1%91%E6%80%A7%E5%8A%9F%E7%9A%84%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%AE%97%E4%BE%8B-%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/">上限法中塑性功的数值积分算例——三重积分</a>）；并且通过Simpson公式也可以保证精度。